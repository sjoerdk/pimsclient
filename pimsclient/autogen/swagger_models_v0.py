# generated by datamodel-codegen:
#   filename:  pims_openapi_def_v0.json
#   timestamp: 2024-04-24T08:07:07+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel, Extra, Field, conint, constr


class ActivityDescriptions(Enum):
    None_ = 'None'
    UpdateWebhook = 'UpdateWebhook'
    CreateKeyfile = 'CreateKeyfile'
    UpdateKeyfile = 'UpdateKeyfile'
    ArchiveKeyfile = 'ArchiveKeyfile'
    UnarchiveKeyfile = 'UnarchiveKeyfile'
    DeleteKeyfile = 'DeleteKeyfile'
    AddUser = 'AddUser'
    UpdateUser = 'UpdateUser'
    DeleteUser = 'DeleteUser'
    AddOrUpdateRole = 'AddOrUpdateRole'
    RemoveRole = 'RemoveRole'
    CreateDataHeader = 'CreateDataHeader'
    UpdateDataHeader = 'UpdateDataHeader'
    DeleteDataHeader = 'DeleteDataHeader'
    CreateDataField = 'CreateDataField'
    UpdateDataField = 'UpdateDataField'
    DeleteDataField = 'DeleteDataField'
    CreatePseudonym = 'CreatePseudonym'
    UpdatePseudonym = 'UpdatePseudonym'
    DeletePseudonym = 'DeletePseudonym'
    CreateIdentity = 'CreateIdentity'
    DeleteIdentity = 'DeleteIdentity'
    CreatePseudonymWithData = 'CreatePseudonymWithData'
    Pseudonymize = 'Pseudonymize'
    Reidentify = 'Reidentify'
    ReidentifyIdentities = 'ReidentifyIdentities'
    ReidentifyTowardsFile = 'ReidentifyTowardsFile'
    ReidentifyIdentitiesTowardsFile = 'ReidentifyIdentitiesTowardsFile'
    RepseudonymizeToOtherKeyfile = 'RepseudonymizeToOtherKeyfile'
    RepseudonymizeFromOtherKeyfile = 'RepseudonymizeFromOtherKeyfile'
    UndoActivity = 'UndoActivity'
    CheckPseudonyms = 'CheckPseudonyms'
    CheckIdentities = 'CheckIdentities'
    GetIdentityByPseudonym = 'GetIdentityByPseudonym'
    GetIdentity = 'GetIdentity'
    MigrationEvent = 'MigrationEvent'
    MigratedEvent = 'MigratedEvent'
    MarkDeletableKeyfile = 'MarkDeletableKeyfile'


class ActivityFields(Enum):
    None_ = 'None'
    ID = 'ID'
    User = 'User'
    Activity = 'Activity'
    Date = 'Date'
    Keyfile = 'Keyfile'
    Description = 'Description'


class CreateDataFieldRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    identity: Optional[str] = Field(
        None,
        description='Identity to link this field with (required if using identities to identify the row to connect this with, optional if using pseudonyms).',
    )
    identitySource: Optional[str] = Field(
        None,
        description='Identity source to link this field with (required if using identities to identify the row to connect this with, optional if using pseudonyms).',
    )
    pseudonym: Optional[str] = Field(
        None,
        description='Pseudonym to link this field with (not to be used if using identities to identify the row to connect this with, required if using pseudonyms).',
    )
    headerID: Optional[int] = Field(
        None,
        description='Primary key of the header under which this field should be placed',
    )
    value: constr(min_length=1, max_length=2048) = Field(
        ...,
        description='Field value (always string)\r\nData is always stored as-is, as a string. data offered as object (int, floats, booleans, datetime) in e.g. excel files will be converted to string (ISO-compliant formatting)',
    )


class CreateKeyfileRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    name: constr(min_length=3, max_length=128) = Field(
        ..., description='Name of the keyfile.'
    )
    pseudonymTemplate: constr(min_length=1, max_length=256) = Field(
        ...,
        description='Pseudonymtemplate.\r\nThe pseudonymtemplate consist of sections cordoned of with a pipe symbol (|). Each section consists of a section type marker in the form of a single character followed by a number or text.\r\nFor more info see help page.',
    )
    description: Optional[constr(max_length=1024)] = Field(
        None, description='A optional description of the keyfile.'
    )
    sequenceNumber: Optional[conint(ge=0)] = Field(
        None,
        description='Sequence number. A number that is incremented each time it is used, therefor offering a source for generating a pseudonym containing a sequential number (using the sxxx section).\r\nThe use of sequential numbers is not recommended if the order in which participants are added to your keyfile can potentially expose which pseudonym is which participant.\r\nOnce set, a sequence number can only go up.',
    )


class CreateKeyfileWithOwnerRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    name: constr(min_length=3, max_length=128) = Field(
        ..., description='Name of the keyfile.'
    )
    pseudonymTemplate: constr(min_length=1, max_length=256) = Field(
        ...,
        description='Pseudonymtemplate.\r\nThe pseudonymtemplate consist of sections cordoned of with a pipe symbol (|). Each section consists of a section type marker in the form of a single character followed by a number or text.\r\nFor more info see help page.',
    )
    description: Optional[constr(max_length=1024)] = Field(
        None, description='A optional description of the keyfile.'
    )
    sequenceNumber: Optional[conint(ge=0)] = Field(
        None,
        description='Sequence number. A number that is incremented each time it is used, therefor offering a source for generating a pseudonym containing a sequential number (using the sxxx section).\r\nThe use of sequential numbers is not recommended if the order in which participants are added to your keyfile can potentially expose which pseudonym is which participant.\r\nOnce set, a sequence number can only go up.',
    )
    owner: UUID = Field(..., description='THe owner (AzureAD ObjectID) of the keyfile')


class CreatePseudonymIdentityRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    value: Optional[constr(max_length=512)] = Field(
        None, description='Identity to add (e.g. patient number)'
    )
    identitySource: Optional[constr(max_length=256)] = Field(
        None,
        description='Identity source to add (e.g. patientMrn).\r\nUsed to distinguish patient numbers from different institutions and/or similar-looking identifiers.',
    )
    pseudonym: Optional[constr(max_length=512)] = Field(
        None, description='Pseudonym to use'
    )
    generatePseudonym: Optional[bool] = Field(
        None,
        description="If true, will generate a new pseudonym using the keyfile's template; otherwise, the given pseudonym will be used. Defaults to True",
    )
    fields: Optional[List[CreateDataFieldRequest]] = Field(
        None,
        description='if present, fields will be added to the entry; If they do not pass validation, no action will take place',
    )


class CreateUserRoleRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    userID: Optional[UUID] = Field(
        None, description='Primary key of the user row (AzureAD ObjectID)'
    )
    roleDefinitionID: Optional[UUID] = Field(
        None,
        description='Role definition ID, refers to one of the role definitions granted to this user',
    )


class DataFieldFields(Enum):
    None_ = 'None'
    Identity = 'Identity'
    Value = 'Value'
    DataHeader = 'DataHeader'
    ID = 'ID'


class DataHeaderFields(Enum):
    None_ = 'None'
    ID = 'ID'
    Name = 'Name'
    Description = 'Description'
    ValueType = 'ValueType'
    DisplayOrder = 'DisplayOrder'


class IdentitiesReidentificationRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    value: List[str] = Field(
        ...,
        description='A list of 1-1000 identities to reidentify',
        max_items=1000,
        min_items=1,
    )
    identitySource: constr(min_length=1) = Field(
        ..., description='A identitysource to reidentify'
    )


class IdentitiesRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    identitySource: constr(min_length=1) = Field(
        ..., description='Identity source, e.g. PatientMrn'
    )
    identities: List[str] = Field(
        ...,
        description='A list of identities, e.g. patient numbers, one per line',
        max_items=1000,
        min_items=1,
    )


class KeyfileFields(Enum):
    None_ = 'None'
    ID = 'ID'
    Name = 'Name'
    Description = 'Description'
    Archived = 'Archived'
    Deletable = 'Deletable'
    Activities = 'Activities'
    Created = 'Created'


class LogLevel(Enum):
    Trace = 'Trace'
    Debug = 'Debug'
    Information = 'Information'
    Warning = 'Warning'
    Error = 'Error'
    Critical = 'Critical'
    None_ = 'None'


class ProblemDetails(BaseModel):
    type: Optional[str] = None
    title: Optional[str] = None
    status: Optional[int] = None
    detail: Optional[str] = None
    instance: Optional[str] = None


class PseudonymisationAction(Enum):
    Store = 'Store'
    Pseudonym = 'Pseudonym'
    Identifier = 'Identifier'
    IdentitySource = 'IdentitySource'
    PseudonymFromOtherKeyfile = 'PseudonymFromOtherKeyfile'
    PseudonymOutput = 'PseudonymOutput'
    None_ = 'None'
    Clear = 'Clear'
    Return_masked = 'Return_masked'
    Return_masked_yyyy = 'Return_masked_yyyy'


class PseudonymsReidentificationRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    value: List[str] = Field(
        ...,
        description='List of 1-1000 pseudonyms to reidentify',
        max_items=1000,
        min_items=1,
    )


class PseudonymsRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    pseudonyms: List[str] = Field(
        ...,
        description='A list of pseudonymns, between 1 and 1000 long.',
        max_items=1000,
        min_items=1,
    )


class ReidentificationRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    pseudonyms: Optional[PseudonymsReidentificationRequest] = None
    identities: Optional[IdentitiesReidentificationRequest] = None
    columns: Optional[List[str]] = Field(
        None, description='A list of columns to reidentify.'
    )
    targetKeyfileID: Optional[int] = Field(
        None, description='The id of an existing keyfile to copy the results to.'
    )
    activityID: Optional[int] = Field(None, description='Activity ID to reidentify')
    targetKeyfile: Optional[CreateKeyfileRequest] = None


class RoleFields(Enum):
    None_ = 'None'
    ID = 'ID'
    User = 'User'
    RoleDefinitionID = 'RoleDefinitionID'


class SortDirection(Enum):
    Ascending = 'Ascending'
    Descending = 'Descending'


class StatusMessage(BaseModel):
    class Config:
        extra = Extra.forbid

    minValue: Optional[datetime] = None
    maxValue: Optional[datetime] = None
    title: Optional[str] = None
    message: Optional[str] = None
    level: Optional[LogLevel] = None


class StringPagedResults(BaseModel):
    class Config:
        extra = Extra.forbid

    page: Optional[int] = Field(None, description='Current page.')
    pageSize: Optional[int] = Field(None, description='Current page size.')
    totalCount: Optional[int] = Field(
        None,
        description='Total amount of items, if calculated. Otherwise, this number will be (Page * PageSize).',
    )
    countComplete: Optional[bool] = Field(
        None,
        description='If set to true, the amount under TotalCount is not the actual total, but the total so far. You can still fetch more pages.',
    )
    items: Optional[List[str]] = Field(None, description='The data.')


class TableAction(Enum):
    None_ = 'None'
    Create = 'Create'
    Read = 'Read'
    Update = 'Update'
    Delete = 'Delete'
    Audit = 'Audit'
    SetArchived = 'SetArchived'
    Deidentify = 'Deidentify'
    Reidentify = 'Reidentify'


class TestKeyfilePseudonymTemplateRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    sequenceNumber: Optional[int] = Field(
        None,
        description='Sequence number. A number that is incremented each time it is used, therefor offering a source for generating a pseudonym containing a sequential number (using the sxxx section).\r\nSet this to a number > 0 if you want to test pseudonym generation with a higher start sequence number',
    )
    pseudonymTemplate: constr(min_length=1, max_length=256) = Field(
        ...,
        description='Pseudonymtemplate.\r\nThe pseudonymtemplate consist of sections cordoned of with a pipe symbol (|). Each section consists of a section type marker in the form of a single character followed by a number or text.\r\nFor more info see help page.',
    )
    identitySources: Optional[List[str]] = Field(
        None,
        description="A list of identity sources which can be used to activate different subsections of your keyfile template (see ':' section)",
    )
    count: Optional[conint(ge=1, le=100)] = Field(
        None, description='The number of pseudonyms to generate'
    )


class UpdateDataFieldRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    id: Optional[int] = Field(None, description='Primary key of the data field')
    value: constr(min_length=1, max_length=2048) = Field(
        ...,
        description='Updated field value (always string)\r\nData is always stored as-is, as a string. data offered as object (int, floats, booleans, datetime) in e.g. excel files will be converted to string (ISO-compliant formatting)',
    )


class UpdateDataHeaderRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    name: constr(min_length=3, max_length=128) = Field(
        ..., description='Name of the data header'
    )
    description: Optional[constr(min_length=0, max_length=256)] = Field(
        None, description='Description of the header'
    )
    valueType: constr(min_length=1) = Field(
        ...,
        description='Type of the header, used to translate to a browser-compatible input.\r\nex. text, number, datetime, date, time, phone',
    )
    defaultAction: Optional[PseudonymisationAction] = None
    validation: Optional[constr(min_length=0, max_length=256)] = Field(
        None,
        description='Validation for this column. This will be triggered whenever a field is added, but not when that happens as part of a bulk upload. Valid options are:\r\nemail()\r\nlength(min)\r\nlength(min, max)\r\nphone()\r\nregex([regex])\r\nrange(min,max)\r\noptions(option1, option2, option3)',
    )
    displayOrder: Optional[int] = Field(None, description='Display order')
    id: Optional[int] = Field(None, description='Primary key of the data header')


class UpdateIdentityRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    id: Optional[int] = Field(None, description='Primary key of the identity to update')
    pseudonym: Optional[constr(max_length=512)] = Field(
        None, description='The new pseudonym'
    )
    generatePseudonym: Optional[bool] = Field(
        None,
        description="If true, will generate a new pseudonym using the keyfile's template; otherwise, thge given pseudonym will be used.",
    )


class UpdatePseudonymRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    id: Optional[int] = Field(None, description='Primary key of the identity to update')
    value: constr(min_length=1, max_length=512) = Field(..., description='New identity')
    identitySource: constr(min_length=1, max_length=256) = Field(
        ..., description='New identity source'
    )


class UpdateUserRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    id: Optional[UUID] = Field(None, description='Primary key (AzureAD ObjectID)')
    enabled: Optional[bool] = Field(
        None, description='If enabled is false, this user is blocked from using PIMS.'
    )
    email: Optional[str] = Field(None, description='Email address')
    displayName: Optional[str] = Field(None, description='Display name')


class UserFields(Enum):
    None_ = 'None'
    DisplayName = 'DisplayName'
    Email = 'Email'


class UserResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    id: Optional[UUID] = Field(None, description='Primary key (AzureAD ObjectID)')
    enabled: Optional[bool] = Field(
        None, description='If enabled is false, this user is blocked from using PIMS.'
    )
    displayName: Optional[str] = Field(
        None, description="This users' displayname, as synced from AzureAD"
    )
    email: Optional[str] = Field(
        None, description="This users' email address, as synced from AzureAD"
    )


class UserResponsePagedResults(BaseModel):
    class Config:
        extra = Extra.forbid

    page: Optional[int] = Field(None, description='Current page.')
    pageSize: Optional[int] = Field(None, description='Current page size.')
    totalCount: Optional[int] = Field(
        None,
        description='Total amount of items, if calculated. Otherwise, this number will be (Page * PageSize).',
    )
    countComplete: Optional[bool] = Field(
        None,
        description='If set to true, the amount under TotalCount is not the actual total, but the total so far. You can still fetch more pages.',
    )
    items: Optional[List[UserResponse]] = Field(None, description='The data.')


class VersionInfo(BaseModel):
    class Config:
        extra = Extra.forbid

    from_: Optional[datetime] = Field(None, alias='from')
    to: Optional[datetime] = None


class WebhookState(Enum):
    Disabled = 'Disabled'
    FinalRetry = 'FinalRetry'
    SecondRetry = 'SecondRetry'
    FirstRetry = 'FirstRetry'
    Enabled = 'Enabled'


class ActivityResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    id: Optional[int] = Field(None, description='Primary Key.')
    user: Optional[UserResponse] = None
    activity: Optional[str] = Field(
        None, description='Descriptive name of the activity.'
    )
    date: Optional[datetime] = Field(
        None, description='Date at which the activity took place.'
    )
    keyfileID: Optional[int] = Field(
        None, description='Primary key of the Keyfile affected or involved.'
    )
    undoActivityID: Optional[int] = Field(
        None,
        description='If this activity was undone, this is a refernece to the undo-activity',
    )
    additionalInformation: Optional[Dict[str, str]] = Field(
        None, description='Optional details.'
    )
    formattedMessage: Optional[str] = Field(
        None, description='Formatted detailed message'
    )
    extraInformation: Optional[str] = Field(None, description='Link to details')
    extraMessages: Optional[str] = Field(
        None,
        description='Additional field containing messages about an activiy that is not stored in the database, e.g. row-for-row details concerning pseudonymisation.',
    )


class ActivityResponsePagedResults(BaseModel):
    class Config:
        extra = Extra.forbid

    page: Optional[int] = Field(None, description='Current page.')
    pageSize: Optional[int] = Field(None, description='Current page size.')
    totalCount: Optional[int] = Field(
        None,
        description='Total amount of items, if calculated. Otherwise, this number will be (Page * PageSize).',
    )
    countComplete: Optional[bool] = Field(
        None,
        description='If set to true, the amount under TotalCount is not the actual total, but the total so far. You can still fetch more pages.',
    )
    items: Optional[List[ActivityResponse]] = Field(None, description='The data.')


class CreateDataHeaderRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    name: constr(min_length=3, max_length=128) = Field(
        ..., description='Name of the data header'
    )
    description: Optional[constr(min_length=0, max_length=256)] = Field(
        None, description='Description of the header'
    )
    valueType: constr(min_length=1) = Field(
        ...,
        description='Type of the header, used to translate to a browser-compatible input.\r\nex. text, number, datetime, date, time, phone',
    )
    defaultAction: Optional[PseudonymisationAction] = None
    validation: Optional[constr(min_length=0, max_length=256)] = Field(
        None,
        description='Validation for this column. This will be triggered whenever a field is added, but not when that happens as part of a bulk upload. Valid options are:\r\nemail()\r\nlength(min)\r\nlength(min, max)\r\nphone()\r\nregex([regex])\r\nrange(min,max)\r\noptions(option1, option2, option3)',
    )
    displayOrder: Optional[int] = Field(None, description='Display order')


class DataFieldResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    id: Optional[int] = Field(None, description='Primary key of the data field')
    headerID: Optional[int] = Field(None, description='Primary key of the data header')
    value: Optional[str] = Field(None, description='Field value (always string)')
    activity: Optional[ActivityResponse] = None
    versionInfo: Optional[VersionInfo] = None


class DataFieldResponsePagedResults(BaseModel):
    class Config:
        extra = Extra.forbid

    page: Optional[int] = Field(None, description='Current page.')
    pageSize: Optional[int] = Field(None, description='Current page size.')
    totalCount: Optional[int] = Field(
        None,
        description='Total amount of items, if calculated. Otherwise, this number will be (Page * PageSize).',
    )
    countComplete: Optional[bool] = Field(
        None,
        description='If set to true, the amount under TotalCount is not the actual total, but the total so far. You can still fetch more pages.',
    )
    items: Optional[List[DataFieldResponse]] = Field(None, description='The data.')


class DataHeaderResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    id: Optional[int] = Field(None, description='Primary key of the data header')
    keyfileID: Optional[int] = Field(
        None, description='Primary key of the data header keyfile'
    )
    name: Optional[str] = Field(None, description='Name of the data header')
    description: Optional[str] = Field(None, description='Description of the header')
    valueType: Optional[str] = Field(
        None,
        description='Type of the header, used to translate to a browser-compatible input.',
    )
    defaultAction: Optional[PseudonymisationAction] = None
    validation: Optional[str] = Field(None, description='Validation rule')
    displayOrder: Optional[int] = Field(None, description='Column display order (GUI)')
    activity: Optional[ActivityResponse] = None
    versionInfo: Optional[VersionInfo] = None


class DataHeaderResponsePagedResults(BaseModel):
    class Config:
        extra = Extra.forbid

    page: Optional[int] = Field(None, description='Current page.')
    pageSize: Optional[int] = Field(None, description='Current page size.')
    totalCount: Optional[int] = Field(
        None,
        description='Total amount of items, if calculated. Otherwise, this number will be (Page * PageSize).',
    )
    countComplete: Optional[bool] = Field(
        None,
        description='If set to true, the amount under TotalCount is not the actual total, but the total so far. You can still fetch more pages.',
    )
    items: Optional[List[DataHeaderResponse]] = Field(None, description='The data.')


class JsonDataHeader(BaseModel):
    class Config:
        extra = Extra.forbid

    name: Optional[str] = None
    type: Optional[str] = None
    pseudonymisationAction: Optional[PseudonymisationAction] = None
    values: Optional[List] = None


class PseudonymIdentityResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    id: Optional[int] = Field(
        None,
        description='Primary key of the identity. Usually not returned unless user has authority to view them',
    )
    value: Optional[str] = Field(
        None, description='Identity of this entry (empty if not authorised or not set)'
    )
    identitySource: Optional[str] = Field(
        None,
        description='Identity sourrce of this entry (empty if not authorised or not set)',
    )
    pseudonym: Optional[str] = Field(
        None, description='Pseudonym of this entry (empty if not authorised or not set)'
    )
    fields: Optional[List[DataFieldResponse]] = Field(
        None,
        description='Field values returned for reidentification purposes. Empty if no data is requested.',
    )
    activity: Optional[ActivityResponse] = None
    versionInfo: Optional[VersionInfo] = None
    dataResponse: Optional[Dict[str, str]] = None


class PseudonymIdentityResponsePagedResults(BaseModel):
    class Config:
        extra = Extra.forbid

    page: Optional[int] = Field(None, description='Current page.')
    pageSize: Optional[int] = Field(None, description='Current page size.')
    totalCount: Optional[int] = Field(
        None,
        description='Total amount of items, if calculated. Otherwise, this number will be (Page * PageSize).',
    )
    countComplete: Optional[bool] = Field(
        None,
        description='If set to true, the amount under TotalCount is not the actual total, but the total so far. You can still fetch more pages.',
    )
    items: Optional[List[PseudonymIdentityResponse]] = Field(
        None, description='The data.'
    )


class PseudonymisationResults(BaseModel):
    class Config:
        extra = Extra.forbid

    results: Optional[List[JsonDataHeader]] = None
    comments: Optional[str] = None


class ReidentificationResult(BaseModel):
    class Config:
        extra = Extra.forbid

    pseudonyms: Optional[PseudonymIdentityResponsePagedResults] = None
    headers: Optional[List[DataHeaderResponse]] = Field(
        None, description='headers found in reidentification query.'
    )


class RoleDefinition(BaseModel):
    class Config:
        extra = Extra.forbid

    assignable: Optional[bool] = Field(None, description='Can the role be used?')
    id: Optional[UUID] = Field(None, description='Role defintion ID, unique identifier')
    name: Optional[str] = Field(None, description='Nice name of the role')
    description: Optional[str] = Field(
        None, description='longer description of the role.'
    )
    actions: Optional[Dict[str, TableAction]] = Field(
        None, description='Actions a user is allowed in this role.'
    )


class RoleDefinitionPagedResults(BaseModel):
    class Config:
        extra = Extra.forbid

    page: Optional[int] = Field(None, description='Current page.')
    pageSize: Optional[int] = Field(None, description='Current page size.')
    totalCount: Optional[int] = Field(
        None,
        description='Total amount of items, if calculated. Otherwise, this number will be (Page * PageSize).',
    )
    countComplete: Optional[bool] = Field(
        None,
        description='If set to true, the amount under TotalCount is not the actual total, but the total so far. You can still fetch more pages.',
    )
    items: Optional[List[RoleDefinition]] = Field(None, description='The data.')


class UpdateKeyfileRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    id: Optional[int] = Field(None, description='Primary key of the keyfile')
    name: Optional[constr(min_length=3, max_length=128)] = Field(
        None, description='New name.'
    )
    pseudonymTemplate: Optional[constr(max_length=256)] = Field(
        None, description='New pseudonymtemplate.'
    )
    description: Optional[constr(max_length=1024)] = Field(
        None, description='New description.'
    )
    sequenceNumber: Optional[conint(ge=0)] = Field(
        None,
        description='New sequencenumber (must be at least as high as the existing value).',
    )
    archived: Optional[bool] = Field(
        None,
        description='Set keyfile to archived state. An archived keyfile cannot be changed untill its status is reversed.',
    )
    deletable: Optional[bool] = Field(
        None,
        description='Set keyfile to deletable state. A keyfile can be deleted only if it does not contain data or by an admin only if the deletable flag is set.',
    )
    webhookActivities: Optional[str] = Field(
        None,
        description="Activities that should trigger the webhook\r\nThis is matched against the 'event' value of an activity. *at the end or beginning are allowed, multiple patterns can be added using a comma.\r\n*keyfile matches createkeyfile, updatekeyfile, deletekeyfile, etc\r\ncreate* matches createkeyfile, createrole, etc.\r\ncreate*,*keyfile matches any activity captured by the patterns above\r\n* matches any activity",
    )
    webhookUrl: Optional[str] = Field(
        None,
        description="Url to call to activate a webhook, which will be called (GET'ed) when a new activity is created in this keyfile\r\nThe url will be called with activity, activityID and keyfileID in the url's GET parameters\r\nPlease note that delivery of the call is not guaranteed; service interruptions may cause failure to deliver all actions in your keyfile.\r\nIn addition, the amount of times the webhookUrl is called is limited to X per minute (atm, X=4). Additional activities per minute are discarded",
    )
    webhookStatus: Optional[WebhookState] = None
    defaultIdentitySource: Optional[str] = Field(
        None, description='Default identity source to display'
    )
    showReidentifyAllButton: Optional[bool] = Field(
        None,
        description="Whether to show the 'reidentify all' button directly in the GUI panel",
    )


class UserRoleResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    id: Optional[int] = Field(None, description='Primary key of this role assignment')
    keyfileID: Optional[int] = Field(
        None, description='Primary key of this role assignments keyfile'
    )
    user: Optional[UserResponse] = None
    roleDefinitionID: Optional[UUID] = Field(
        None,
        description='Role definition ID, refers to one of the role definitions granted to this user',
    )
    activity: Optional[ActivityResponse] = None


class UserRoleResponsePagedResults(BaseModel):
    class Config:
        extra = Extra.forbid

    page: Optional[int] = Field(None, description='Current page.')
    pageSize: Optional[int] = Field(None, description='Current page size.')
    totalCount: Optional[int] = Field(
        None,
        description='Total amount of items, if calculated. Otherwise, this number will be (Page * PageSize).',
    )
    countComplete: Optional[bool] = Field(
        None,
        description='If set to true, the amount under TotalCount is not the actual total, but the total so far. You can still fetch more pages.',
    )
    items: Optional[List[UserRoleResponse]] = Field(None, description='The data.')


class FileOptions(BaseModel):
    class Config:
        extra = Extra.forbid

    textCharacter: Optional[str] = None
    splitCharacter: Optional[str] = None
    range: Optional[str] = None
    firstLineIsHeaders: Optional[bool] = None
    commentPrefix: Optional[str] = None
    suggestedHeaders: Optional[List[JsonDataHeader]] = None


class KeyfileResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    id: Optional[int] = None
    name: Optional[str] = None
    pseudonymTemplate: Optional[str] = None
    creationDate: Optional[datetime] = None
    members: Optional[List[UserRoleResponse]] = None
    archived: Optional[datetime] = None
    deletable: Optional[bool] = None
    description: Optional[str] = None
    activities: Optional[List[ActivityResponse]] = None
    sequenceNumber: Optional[int] = None
    activity: Optional[ActivityResponse] = None
    versionInfo: Optional[VersionInfo] = None
    studyID: Optional[str] = None
    webhookActivities: Optional[str] = None
    webhookStatusMessage: Optional[str] = None
    webhookUrl: Optional[str] = None
    webhookStatus: Optional[WebhookState] = None
    lastwebhookCall: Optional[datetime] = None
    defaultIdentitySource: Optional[str] = None
    showReidentifyAllButton: Optional[bool] = None


class KeyfileResponsePagedResults(BaseModel):
    class Config:
        extra = Extra.forbid

    page: Optional[int] = Field(None, description='Current page.')
    pageSize: Optional[int] = Field(None, description='Current page size.')
    totalCount: Optional[int] = Field(
        None,
        description='Total amount of items, if calculated. Otherwise, this number will be (Page * PageSize).',
    )
    countComplete: Optional[bool] = Field(
        None,
        description='If set to true, the amount under TotalCount is not the actual total, but the total so far. You can still fetch more pages.',
    )
    items: Optional[List[KeyfileResponse]] = Field(None, description='The data.')


class PseudonymisationRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    fileOptions: FileOptions
    targetKeyfileID: Optional[int] = Field(
        None,
        description='Optional keyfile id, in case you want to send this data to another keyfile that already exists.',
    )
    identitySource: Optional[constr(min_length=1, max_length=256)] = Field(
        None,
        description='Optional if you want to use one identity source for all input rows. Otherwise, you can mark a column as identitysource to have (optionally) different sources in a single file.',
    )
    targetKeyfile: Optional[CreateKeyfileRequest] = None


class DataSet(BaseModel):
    class Config:
        extra = Extra.forbid

    comment: Optional[str] = None
    countComplete: Optional[bool] = None
    data: Optional[List[JsonDataHeader]] = None
    suggestedOptions: Optional[FileOptions] = None
